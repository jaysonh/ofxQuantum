/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Complex.cpp
//
//  Created by Jayson Haebich, 2016 www.jaysonh.com
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <math.h>
#include "complex.h"

////////////////////////////////////////////////////
// Default constructor, initializes to 0 + i0     //
////////////////////////////////////////////////////
Complex::Complex()
{
    mReal = 0.0;
    mImag = 0.0;
}

////////////////////////////////////////////////////
// Argument constructor                           //
////////////////////////////////////////////////////
Complex::Complex( const double r, const double i )
{
    mReal = r;
    mImag = i;
}

////////////////////////////////////////////////////
// Destructor                                     //
////////////////////////////////////////////////////
Complex::~Complex()
{

}

////////////////////////////////////////////////////
// Overloaded = operator                          //
////////////////////////////////////////////////////
Complex & Complex::operator = ( const Complex & c )
{
  if ( &c != this )
  {
    mReal = c.getReal();
    mImag = c.getImag();
      
    return *this;
  }
}

////////////////////////////////////////////////////
// Overloaded + operator                          //
////////////////////////////////////////////////////
Complex & Complex::operator + ( const Complex & c )
{
  mReal += c.getReal();
  mImag += c.getImag();
    
  return *this;
}

////////////////////////////////////////////////////
// Overloaded * operator                          //
////////////////////////////////////////////////////
Complex & Complex::operator * ( const Complex & c )
{
  mReal = mReal * c.getReal() - mImag * c.getImag();
  mImag = mReal * c.getImag() + mImag * c.getReal();
    
  return *this;
}

////////////////////////////////////////////////////
// Multiply imaginary part by a float             //
////////////////////////////////////////////////////
Complex & Complex::mult( const float &c )
{
    double r =  mImag * c;
    double i = -mReal * c;
    
    mReal =  r;
    mImag =  i;
    
    return *this;
}

//////////////////////////////////////////////////////
// Overloaded == operator.  Small error tolerances. //
//////////////////////////////////////////////////////
bool Complex::operator==(const Complex &c) const
{
  //This is to take care of round off errors.
  if ( fabs( c.getReal() - mReal ) > pow( 10, -14 ) )
  {
    return false;
  }
  if ( fabs( c.getImag() - mImag ) > pow( 10, -14 ) )
  {
    return false;
  }
  return true;
}

//////////////////////////////////////////////////////
// Set values                                       //
//////////////////////////////////////////////////////
void Complex::set(const double r, const double i)
{
    mReal = r;
    mImag = i;
}

//////////////////////////////////////////////////////
// Returns the real part of the complex number      //
//////////////////////////////////////////////////////
double Complex::getReal() const
{
  return mReal;
}

///////////////////////////////////////////////////////
// Returns the imaginary part of the complex number  //
///////////////////////////////////////////////////////
double Complex::getImag() const
{
  return mImag;
}

//////////////////////////////////////////////////////
// Get teh length of the complex number
//////////////////////////////////////////////////////
double Complex::length()
{
    return sqrt( mReal * mReal + mImag * mImag );
}
